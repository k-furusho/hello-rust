- `cargo clippy --fix --allow-dirty`
  - clippy推奨の書き方に自動で書き換えするコマンド
- data-types#integer-overflow
  - https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow
- 演算子と記号
  - https://doc.rust-jp.rs/book-ja/appendix-02-operators.html
- Rustのライフタイム・所有権・借用
  - ライフタイム：値もしくは参照の有効期間
    - ライフタイムとは、値もしくは参照の有効期間を指す。
    - 値のライフタイムのことを**値のスコープ**とも呼ぶ
    - 有効期限から外れた値や参照を使うことはできず、コンパイルエラーになる。
    - ジェネリックライフタイム注釈（例：`'a`）を使用して、参照の有効期間を明示的に指定できる
    ```rust
    // 例：ライフタイムパラメータの使用
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() { x } else { y }
    }
    ```

  - 所有権：値に対する生殺与奪の権利
    - 所有権(ownership)とは、値の生殺与奪を握る権利のこと。
    値には必ず、所有権を持っている所有者が1つだけ存在する。
    - 1つだけの存在になるために、所有権には次の決まりがある。
      - 変数は値の所有者になれる。
      - 変数のほか、値そのものも別の値の所有者になることが出来る
        - 例：構造体のフィールドに保持された値は、そのフィールドのある構造体型の値が所有者
      - 誰も所有していない状態になると値のスコープが終了し、値が破棄される。
      - 所有権は、別の変数や値に譲渡する(ムーブする)ことができる。所有権を譲渡すると、元の変数や値からは使うことができなくなる。
    - Copy traitを実装している型（基本的な数値型、bool、char等）は値がコピーされ、ムーブではなくコピーセマンティクスとなる

  - 借用:値の参照を一時的に借りること
    - 値の所有者は値の生殺与奪を握るため、その値を自由に使える。が、所有者しか値を使えないとなると、プログラム中で同時に1箇所でしか値を使えなくなるため、値の所有者から、値にアクセスするための参照を一時的に借りることができる。これが参照の借用(borrow)
  - 大原則である「同時に複数箇所で値を編集してさえいなければ、何カ所で同時に値を読み取ろうが安全」を保つため、参照と借用には次の決まりがある
    - 所有権を持つ値を借用して、可変参照と不変参照を作ることができる。
    - ただし、可変参照を作れるのは元の値が可変な場合のみ。
      - ほかの参照が有効な間は可変参照を作れない。
      - つまり、同じ値に対する参照は次のいずれかになる
        - ただ 1つの可変参照がある
        - 0個以上の不変参照があり、可変参照はない
        - 可変参照は不変参照に変換できるが、その逆はできない
      - 参照のライフタイムは、参照が使われなくなった時点で終了する
      - 参照元の値のスコープより参照のライフタイムを長くすることはできない
- 借用の種類：
  1. 不変借用（`&T`）
     - 読み取り専用
     - 複数同時に存在可能
  2. 可変借用（`&mut T`）
     - 読み書き可能
     - 同時に1つのみ存在可能
- 引数の受け取り方
  1. 可変参照（`&mut T`）
     - 渡された値を関数の中で書き換えるとき
     - ほかの関数に可変参照を渡す必要があるとき
  2. 値（`T`）
     - 関数の中で値の所有権が必要なとき
     - コピーセマンティクスの値を受け取るとき
     - `Clone`を実装している型で、関数内で独自のコピーが必要なとき
  3. 不変参照（`&T`）
     - 上記に当てはまらない場合
     - 特に文字列の場合：
       - `String`：所有権が必要な場合
       - `&str`：参照で十分な場合（推奨）
     - コレクションの場合：
       - スライス（`&[T]`）：固定長の参照が必要な場合
       - `Vec<T>`：可変長や所有権が必要な場合

- 実践的なパターン：
  - 文字列を引数に取る関数の例：
    ```rust
    // 参照を受け取る場合（推奨）
    fn process_str(s: &str) { ... }

    // 所有権が必要な場合
    fn take_ownership(s: String) { ... }
    ```
  - コレクションを引数に取る関数の例：
    ```rust
    // スライスで受け取る場合（推奨）
    fn process_items(items: &[i32]) { ... }

    // 所有権が必要な場合
    fn take_items(items: Vec<i32>) { ... }
    ```